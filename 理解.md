**未使用定义变量关键字**(var,let,const),对变量进行修饰除了在类中或者对象中，其他的默认会挂载到window对象中，并且在函数中调用该函数没有定义的变量，该函数会逐层向上查找，最后都是到window对象中查找

**最外层使用var来定义变量**会默认将该变量挂载到window上，和没有加定义变量关键字的变量效果一样，当使用let或者const来定义变量，变量不会被挂载到window对象中，因为let,const有作用域

不能再类中不使用定义变量关键字来定义变量，如:a = 15;而要 var a = 15;

在类中把一般通过this.的方式来变量定义在实例化对象中，不会定义在他的本身中，而方法会定义在本身中__proto__对象中,变量会定义在实例化对象中，所有说一个类的原型中是没有变量的只有方法，想要在原型中添加变量通过子代的实例化对象.__proto__或者类.prototype来进行命名，并且在类中是不能访问类的子代给原型中添加的方法和变量
**当在类中使用箭头函数定义方法，该方法也不会挂载到该类的原型中**

类的访问顺序:本身类**如果有继承父类，该子类会继承父类实例化中的所有的变量和方法**->原型->原型的原型,
原型:就是该对象的构造函数中所继承的其他对象，这个其他对象就是该对象的原型
原型链:每个对象中的构造函数所继承的其他对象，结合形成的虚拟链

在构造函数定义的属性和方法都会被挂载到实例化对象中，只有定义在非构造函数中的方法会自动挂载到该实例化对象的原型上，但是定义在非构造函数中的变量还是会挂载到实例化对象中，但是除非使用prototype手动挂载，否则变量不会挂载到原型中

原型等于实例化对象
原型中包含:{
    1.后代向原型中添加的变量和函数，并且这些变量和函数只能在后代中通过原型或者原型链来获取或者调用
    2.constructor:指向原型子类的类对象，并非这个类的实例化对象，也不能方法这个实例化对象中的变量和方法
    3.__proto__:指向下一个原型对象，Ojbect.prototype.__proto__为null
}
实例化对象:{
    只有一个__porto__属性
}
最高的原型就是Object的原型对象=Object.prototype

闭包:有权访问到另一个函数内部定义的变量**或者**一个作用域可以访问另一个函数内部的局部变量{
    优点:隐藏变量，避免变量被污染
    缺点:常驻内存 会增大内存的使用量 使用不当会造成内存泄露，详解：由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成页面的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。
    谣言:闭包会造成内存泄漏:错;;因为:内存泄露是指你用不到（访问不到）的变量，依然占居着内存空间，不能被再次利用起来。闭包里面的变量明明就是我们需要的变量（lives），凭什么说是内存泄露？因为 IE。IE 有 bug，IE 在我们使用完闭包之后，依然回收不了闭包里面引用的变量。这是 IE 的问题，不是闭包的问题。

~JScript.dll – 不回收，内存无下降趋势。
~Chakra – 回收，内存会恢复到outer函数执行前的状态。
~Carakan – 不回收，内存无下降趋势。
~V8 – 回收，访问largeObject抛出ReferenceError。
~SpiderMonkey – 回收，访问largeObject得到undefined。
}
作用域:{
    全局作用域:{
        1.使用var定义在全局的变量成为全局作用域，全局作用域会自动被挂载到window的对象中
        2.未定义直接进行赋值的变量会自动变为全局作用域，然后被挂载到window对象中
    }
    局部作用域:{
        1.只有在函数中才有作用域
    }
    块级作用域
}
作用域链:{
    在函数中先看自己的作用域，如果没有该变量，就向上一级作用域查看，直到全局作用域
}

箭头函数中有一个自己的堆内存，堆内存中存放的有this的指向，当箭头函数第一次被定义时**不是被调用**就会从自身开始向上一个作用域开始查找this查找到this之后就将this保存在箭头函数独有的堆内存中，以后每次调用this都指向自身堆内存中保留的this

vue中的响应式:{
    vue2:Object.defineProperty:使用数据劫持来实现双向绑定:{
        缺点:{
            1.如果vue中data数据过多会造成就需要多层递归去解析对象中的属性，依次添加set和get方法:增加浏览器的工作量
        }
    }
}
AST:抽象DOM树
VUE的本质:使用HTML的字符串作为模板==》模板->AST(最消耗性能,要对字符串进行操作),AST->VNode,VNode->真实DOM

vue中render和template是一样的都是用来创建HTML模板，但是template来创建模板会造成代码冗长繁琐而且有大量重复
render一个函数:{
    1.返回值:VNode虚拟DOM
}

作用域:{
    当一个函数被定义时，该函数就会被定义一个scope属性在scope属性的第0位存放的为GO作用域的地址
    当该函数被调用时，该函数就会在scope属性中的第0位指向自己的AO作用域的地址，然后之前的内容依次向下平移
    定义时             
    scope 作用域链
    -------------           |---------------|
    |0   |GO地址|---------》|a | 12         |
    |    |      |           |b |function    |
    -------------           |---------------|
    调用时
    scope 作用域链
    -------------
    |0   |AO地址|
    |1   |GO地址|
    -------------

    当出现:function fn(){function fnn(){ function fnnn(){}}}
    作用域就会一个一个添加到顶部
    比如:fnnn的作用域:定义时
    ------------------------
    |scope 作用域链        |
    ------------------------
    | 0  |fnn执行期的上下文|
    | 1  |fn执行期的上下文 |
    | 2  |GO执行期的上下文 |
    ------------------------
    比如:fnnn的作用域:调用时
    -------------------------
    |scope 作用域链         |
    -------------------------
    | 0  |fnnn执行期的上下文|
    | 1  |fnn执行期的上下文 |
    | 2  |fn执行期的上下文  |
    | 3  |GO执行期的上下文  |
    -------------------------
}